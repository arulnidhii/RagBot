# RAGBot

**RAGBot** is a answers user questions using a **Retrieval-Augmented Generation (RAG)** pipeline.  It combines semantic search over a knowledge base with a large language model (LLM) to produce accurate, up-to-date answers grounded in external documents. In practice, the bot **ingests documents** (e.g. PDFs, text, or database content), embeds them with a neural embedding model, and stores the embeddings in a vector database.  At query time, the user’s question is also embedded and used to retrieve the most relevant document chunks via similarity search. These retrieved snippets are then concatenated with the original question and passed to the LLM to generate the final answer. This hybrid approach ensures responses are **contextualized and factual**, since the LLM is always “grounded” on actual reference material rather than relying solely on its training data.

## Features

* **Retrieval-based QA:** Answers are generated by combining a semantic search retriever with a powerful LLM generator, improving relevance and factuality.
* **External Knowledge Base:** The bot can ingest and index any document corpus (PDFs, text files, databases) into a vector store. This knowledge base can be kept up-to-date independently of the LLM’s training.
* **Up-to-date and Accurate:** By fetching fresh information at runtime, RAG reduces hallucinations and outdated responses.  It “bridges the gap” between static model knowledge and dynamic content.
* **Explainable Responses:**  Retrieved context sources can be attached to answers (e.g. PDF titles or document IDs), increasing transparency.
* **Extensible Stack:** The bot is built with modular components (embeddings model, vector store, LLM) that can be swapped or scaled as needed.

## Model Architecture

*Figure: Example RAG system architecture (ingestion of documents into a vector store, and query-time retrieval/generation).* The QuantifyLabsRAGBot follows this standard RAG pipeline: First, documents are **preprocessed** and **embedded**. They are split into manageable text chunks, each converted to a vector embedding using an embedding model (e.g. OpenAI’s `text-embedding-ada-002`, a SentenceTransformer, etc.).  These embeddings (along with metadata) are stored in a **vector database** (via a VectorStore interface) for efficient similarity search.

When a user submits a query, the bot **embeds the query** into the same vector space and performs a nearest-neighbor search against the vector store. The top-\$k\$ most similar document chunks are retrieved as context.  These retrieved texts are concatenated with the original question to form a single prompt. Finally, a **generator model** (e.g. an LLM like GPT-4 or GPT-3.5-turbo) processes this prompt and produces the answer. This means the LLM “sees” both the user’s question and the relevant facts from the documents, grounding its output in real data.

The core components are summarized below:

| Component           | Example Tools / Models                 | Role                                                         |
| ------------------- | -------------------------------------- | ------------------------------------------------------------ |
| **Retriever**       | OpenAI Embeddings, SentenceTransformer | Converts text (docs and queries) into vector embeddings.     |
| **Vector Store**    | Chroma, Pinecone, FAISS, Weaviate      | Stores embeddings and enables fast similarity search.        |
| **Generator (LLM)** | GPT-4, GPT-3.5-Turbo, Llama 2          | Large language model that generates the answer from context. |

Embedding models and vector stores are interchangeable. The bot’s architecture is **model-agnostic**: any high-quality LLM and embedding/vector database can be plugged in. The figure above illustrates this flow. By combining retrieved knowledge with generative power, RAG *significantly improves the relevance and correctness* of answers compared to a vanilla LLM.

## Setup Instructions

1. **Clone the repository:**

   ```bash
   git clone https://github.com/arulnidhii/QuantifyLabsRAGBot.git
   cd QuantifyLabsRAGBot
   ```

2. **Install dependencies:**
   Use Python 3.8+ and create a virtual environment (optional but recommended). Then install required packages:

   ```bash
   python3 -m venv venv
   source venv/bin/activate      # On Windows use venv\Scripts\activate
   pip install -r requirements.txt
   ```

   *(The requirements may include libraries like `langchain`, `openai`, `faiss-cpu`, `sentence-transformers`, etc., depending on the configuration.)*

3. **Configure environment variables:**
   Create a `.env` file or export the following environment variables for your chosen services:

   * `OPENAI_API_KEY` – your OpenAI API key for LLM generation (if using OpenAI models).
   * `PINECONE_API_KEY` & `PINECONE_ENV` – if using Pinecone as the vector store.
   * `MONGO_URI`, `MONGO_DB` – if using MongoDB Atlas for storage (common in LangChain projects).
   * *Any other provider keys*: e.g. `WEAVIATE_URL`, `WEAVIATE_API_KEY`, `AWS_ACCESS_KEY` if using AWS/neural embedding services, etc.

   Example `.env` file contents:

   ```
   OPENAI_API_KEY="sk-..."
   PINECONE_API_KEY="..."
   PINECONE_ENV="us-west4-gcp"
   ```

   Adjust these to match the tools and services you plan to use.

4. **Initialize the index (vector store):**
   If the bot requires a one-time indexing step, run the data ingestion script to build the vector database from your documents.  For example:

   ```bash
   python index_docs.py --data-folder ./docs
   ```

   This will parse the documents, split them into chunks, embed them, and populate the vector store.
   *(Refer to any project-specific scripts provided, such as `build_index.py` or `ingest.py`.)*

5. **Verify setup:**
   Ensure the vector store is populated (e.g. Pinecone index created, FAISS files written, etc.) and that the `.env` keys are correctly set.

## Usage Guide

Once set up, you can run the bot to answer questions. Depending on the implementation, you might have a command-line interface or a code API. For example, to start an interactive session in the terminal:

```bash
python chat.py
```

You should see a prompt like:

```
Enter your question: 
```

Type a question (e.g. *“What is retrieval-augmented generation?”*) and the bot will return an answer generated by the LLM using retrieved context.

Alternatively, you can use it as a Python module in your own scripts:

```python
from QuantifyLabsRAGBot import RAGBot

bot = RAGBot()               # initialize with any required arguments
answer = bot.ask("What topics does Quantify Labs cover?")
print("Bot:", answer)
```

*Examples:*

* Asking domain-specific questions (e.g. about Quantify Labs projects) to get detailed answers grounded in the provided documents.
* Running in streaming mode (if supported) to see tokens as they are generated.
* Integrating the bot into a web or chat service by calling its API functions or command-line interface.

For detailed usage and argument options, run:

```bash
python chat.py --help
```

or refer to the docstrings in the code.

## Contributing Guidelines

We welcome contributions to QuantifyLabsRAGBot! Please follow these guidelines:

* **Issue Tracker:** Report bugs or request features by opening an issue on GitHub. Be descriptive and include code snippets or error messages if possible.
* **Coding Style:** Follow PEP 8 style for Python code. Keep functions focused and well-documented. Include type hints where appropriate.
* **Pull Requests:** Fork the repository and create feature branches for your changes. Open a pull request (PR) against `main` when ready. Ensure your PR has a clear title and description, and reference any related issues.
* **Testing:** If you add functionality, include tests or example usage. Make sure all existing tests still pass.
* **Documentation:** Keep the README and docstrings up to date. If you add a new dependency or config variable, mention it in the docs.
* **Code of Conduct:** Be respectful and constructive. All contributions should adhere to the project’s code of conduct (if one exists).
* **Contact:** If you have questions or ideas, feel free to reach out by commenting on issues or via \[insert preferred contact method].

Thank you for helping improve QuantifyLabsRAGBot!

## License

This project is open-source and licensed under the **MIT License**. See the [LICENSE](LICENSE) file for full license text.

The `RAGBot` may include third-party libraries (e.g. LangChain, OpenAI SDK, FAISS), each subject to their own licenses. By using or contributing to this project, you agree to comply with those licenses as well.
